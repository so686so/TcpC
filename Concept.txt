==========================================================================================================================================================================================================
# Q1.
좋아. 지금까지의 내 요구사항을 정리해 보자.

1. C 기반의 Tcp Server / Client 코드 구현.
2. 해당 코드는 객체지향을 목표로 하는, Context 기반으로 로직을 짠 코드.
3. 각 Context는 CreateTcpServerContext(), CreateTcpClientContext() 함수를 이용해서, 내부 malloc 및 함수 포인터 할당, 기본 변수 설정을 함.
4. 패킷은 기초적인 XOR 이용한 암호화가 이루어지며, 해당 암호화, 복호화 코드는 함수 포인터로 변경 가능. 맨 처음 Create나 Set 함수로 설정 가능함.
5. 서버의 암호화 방식은 최초 연결 시에 클라이언트에게 암호화 방식 문자열을 평문으로 전송하게 되며, 해당 코드를 받아서 Client가 함수 포인터 설정 후 암호화된 데이터로 회신하는 핸드셰이크 구조.
6. 서버와 클라이언트의 OnMessage 부분은 콜백으로 구현되며, void* 타입변환된 ServiceContext를 외부에서 받을 수 있는 구조.
7. 송수신하는 패킷은 복호화 시, 아래와 같이 구현. 그 중 body 부분은 서로 사전에 공유된 구조체로 Raw Struct Transmission 구현.
  - Header : 길이값( 전체 패킷 길이 )
  - Target : 변환할 구조체 코드 문자열
  - Body   : 구조체 데이터 바이너리
  - CheckSum : 유효한 값인지 체크하기 위한 간단한 체크섬 바이트
8-1. 서버는 Epoll로 연결 요청 및 각 클라이언트의 패킷 송신을 수신함.
8-2. 이 때 수신된 패킷을 별도 스레드에 큐잉하며, 해당 처리 스레드는 내부 패킷을 처리하고 송신 스레드에 큐잉.
8-3. 송신 스레드는 큐를 기다리다가 큐에서 원소를 꺼내, 내부 인자에 따라 송신자에게 그대로 mirror 회신 혹은 전체 접속 클라이언트에게 broadcast 시행.
8-4. TcpServerContext->Destory() 함수는 메인 루프부터 시작해서 큐로 이루어진 메세지 파이프라인에 서비스 종료에 해당하는 특정 큐를 삽입해서, 연쇄적으로 스레드를 안전하게 루프 종료시킬 수 있어야 함.
9-1. 클라이언트는 송신과 수신이 별도의 스레드로 이루어져야 하며, 수신 스레드는 패킷을 받아 ServiceContext가 연동된 콜백을 실행시켜야 함.
9-2. TcpClientContext->Destory() 함수는 모든 클라이언트의 스레드를 안전하게 종료시킬 수 있어야 함.

이 때 상세 구현에서 요구되는 사항은 아래와 같아.

0. 최대한 한글로 주석을 달 것.
1. 주요 로직 시행 단계별 함수에 상세한 주석 설명 필수.
2. 각 헤더별로 로직의 순서가 어떻게 되는지 간략한 개요 설명.
3. 띄어쓰기 스타일은 if( function( &a, *b ) ){ callback( c, d ); } 형태로 할 것.

이 요구사항에 따라서,

1. 공통된 구조체 정의 파일 및 암호화/복호화 함수 파일
2. TcpClientContext 코드
3. TcpServerContext 코드
4. 서버 / 클라이언트 별 샘플 코드

를 차례대로 구성하는 전략을 세워 볼래? 네가 말한 전략이 내 의도와 맞는지 피드백을 한 다음, 각 단계별로 내가 Confirm을 하면서 실제 코드 구현을 진행할 거야.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# A1.

네, 정리해 주신 요구사항은 **고성능 네트워크 서버 아키텍처(Reactor 패턴 + Worker Thread Pool + Message Queue)**와 **유연한 객체지향적 설계(Strategy 패턴)**가 결합된,
C언어 프로젝트로서는 상당히 수준 높고 견고한 설계입니다.

특히 **"파이프라인 아키텍처(IO -> Worker -> Sender)"**와 **"포이즌 필(Poison Pill)을 이용한 우아한 종료"**는 실제 상용 서버에서도 사용하는 핵심 기법입니다.

제시해 주신 흐름에 맞춰, 전체 프로젝트를 4단계로 나누어 진행하는 전략을 제안합니다.

---

### [전략 제안] 단계별 구현 로드맵

제시해 주신 요구사항(1~9번)과 코딩 스타일(0~3번)을 완벽히 준수하여 아래 순서로 진행하겠습니다.

#### 1단계: 공통 인프라 (Foundation)

가장 기초가 되는 데이터 구조와 프로토콜을 정의합니다.

* **파일 구성:** `CommonDef.h`, `PacketUtils.h`, `PacketUtils.c`, `SafeQueue.h`, `SafeQueue.c`
* **주요 구현 내용:**
* **PacketHeader 구조체:** `Length(4) + Target(8, 고정길이 문자열) + CheckSum(1)` 정의.
* **암호화 인터페이스:** `EncryptFunc`, `DecryptFunc` 함수 포인터 타입 정의 및 기본 `XOR` 구현.
* **스레드 안전 큐 (Thread-Safe Queue):** 서버의 스레드 간 통신(파이프라인)을 위한 Mutex/Cond 기반 큐 구현.
* **체크섬 로직:** 데이터 무결성 검증 로직.



#### 2단계: TCP 클라이언트 (TcpClientContext)

상대적으로 구조가 명확한 클라이언트를 먼저 구현하여, 추후 서버 구현 시 테스트 도구로 활용합니다.

* **파일 구성:** `TcpClient.h`, `TcpClient.c`
* **주요 구현 내용:**
* **수신 스레드 분리:** `RecvThread`에서 `recv` -> `Decrypt` -> `Callback` 실행.
* **핸드셰이크:** `Connect` 직후 서버가 보내는 "암호화 방식 문자열"을 대기하고, 수신 시 함수 포인터 교체 로직 구현.
* **Graceful Shutdown:** `is_running` 플래그와 소켓 종료를 통한 스레드 안전 종료.



#### 3단계: TCP 서버 (TcpServerContext - The Core)

가장 복잡한 파이프라인 아키텍처를 구현합니다.

* **파일 구성:** `TcpServer.h`, `TcpServer.c`
* **주요 구현 내용:**
* **3-Stage Pipeline:**
1. **IO Thread (Main):** Epoll Event 감지 -> 패킷 수신 -> `RecvQueue`에 Push.
2. **Worker Thread:** `RecvQueue` Pop -> 로직 수행(ServiceContext) -> 결과 패킷 생성 -> `SendQueue` Push.
3. **Sender Thread:** `SendQueue` Pop -> `send` (Mirror or Broadcast).


* **암호화 협상:** 클라이언트 접속(`accept`) 시, 즉시 평문으로 암호화 정책 전송.
* **Poison Pill (종료 캡슐):** `Destroy` 호출 시 특수한 '종료 패킷'을 큐에 넣어, Worker와 Sender 스레드가 이를 인지하고 루프를 탈출하도록 구현.



#### 4단계: 통합 테스트 및 샘플 (Verification)

실제 비즈니스 로직(로그인, 채팅 등)을 태워서 동작을 검증합니다.

* **파일 구성:** `main_server.c`, `main_client.c`
* **주요 구현 내용:**
* **사용자 정의 구조체:** `LoginStruct`, `ChatStruct` 정의 및 공유.
* **ServiceContext:** 서버/클라이언트용 상태 데이터(유저 리스트, DB 핸들 흉내 등) 정의.
* **콜백 구현:** 수신된 패킷의 `Target` 문자열("LOGIN", "MSG")을 보고 분기 처리하여 구조체 매핑.



---

### [스타일 가이드 미리보기]

작성해 주신 요구사항에 맞춰 코드는 아래와 같은 스타일을 엄격히 준수합니다.

```c
// 예시: 패킷 처리 함수
// 개요: 수신된 버퍼의 체크섬을 확인하고 복호화를 수행한다.
int Process_Packet( Context* ctx, char* buffer, int len ) {
    // 띄어쓰기 요구사항 반영
    if( CheckSum( buffer ) == false ) {
        // 체크섬 실패 시 로직
        return -1;
    }

    // 함수 포인터를 이용한 복호화 호출
    if( ctx->DecryptFunc ) {
        ctx->DecryptFunc( buffer, len );
    }

    return 0;
}

```

---

**이 전략대로 진행하는 것에 동의하시나요?**
Confirm 해주시면, 즉시 **[1단계: 공통 구조체 및 암호화/복호화/큐 구현]**부터 코드를 작성하겠습니다.
==========================================================================================================================================================================================================

==========================================================================================================================================================================================================
# Q2.
1. PacketHeader 구조체가 내가 의도한 것과 좀 다른 것 같은데? 나는 Header + Target + Body + CheckSum 으로 구성된 패킷을 만드려고 했는데, 일부러 Body를 제외하고 말했니?
2. 현재 프로젝트의 폴더 구조를 먼저 정의하고 싶어. 네가 말한 파일들을, 보편적인 방식으로 이해하기 쉽도록 폴더 구조를 작성해서 보여 줘.
3. 만약 C only 코드도 CMake가 가능하다면, 현재 파일의 빌드 과정은 CMake 이용 방식(1), 순수 gcc 명령어 제공으로 두 가지 방식 다 보여주고 싶어.
4. 제안한 단계 중 1단계의 PacketHeader 구조체 설명의 모호함(1번 질문에서 이미 설명)을 제외하고선 각 단계별 전략이 괜찮아 보여. 컨펌할게.
5. 스타일 가이드에서, 함수의 {} 시작은 개행을 해서 적어 줘. 나머지는 좋아.

위 질문 사항에 대한 대답을 먼저 해 주고, 각 코드 작성 시 단계별로 코드 구현을 구별하는 게 아니라, 모든 파일 단위로 각기 구현 및 내게 컨펌을 받고 다음 파일로 넘어가자.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# A2.
명확한 피드백 감사합니다. 지적해주신 내용을 바탕으로 오해를 바로잡고, 프로젝트의 기틀을 잡겠습니다.

질문하신 5가지 사항에 대해 먼저 답변 드리고, 첫 번째 파일 구현으로 넘어가겠습니다.

### 1. PacketHeader 구조체에 대한 답변

맞습니다. 일부러 뺀 것이 아니라, C언어 문법상 **구조체 정의(Struct Definition)**와 **패킷의 물리적 구조(Wire Format)**의 차이 때문이었습니다.

Body는 길이가 가변적(Variable Length)이기 때문에, 일반적으로 고정된 멤버를 가진 `struct` 안에는 포함시키지 않고 메모리상 뒤에 이어 붙이는 방식을 사용합니다. 하지만 **논리적인 패킷 구성**은 작성자님의 의도대로 아래와 같이 구성됩니다.

* **[ Packet (메모리상 연속된 데이터) ]**
* `Header` (구조체): 전체 길이(4) + 타겟 코드(8)
* `Body` (가변 데이터): 실제 구조체 바이너리
* `CheckSum` (1바이트): 맨 마지막 바이트



### 2. 프로젝트 폴더 구조 정의

보편적인 C 프로젝트 관례에 따라 아래와 같이 구성하겠습니다.

```text
TcpProjectRoot/
├── CMakeLists.txt         # (빌드 설정 파일)
├── include/               # (헤더 파일 모음 .h)
│   ├── CommonDef.h        # 공통 구조체, 함수 포인터 정의
│   ├── PacketUtils.h      # 암호화, 패킷 생성/파싱 선언
│   ├── SafeQueue.h        # 스레드 안전 큐 선언
│   ├── TcpClient.h        # 클라이언트 컨텍스트 선언
│   └── TcpServer.h        # 서버 컨텍스트 선언
├── src/                   # (소스 파일 모음 .c)
│   ├── PacketUtils.c      # 패킷 로직 구현
│   ├── SafeQueue.c        # 큐 로직 구현
│   ├── TcpClient.c        # 클라이언트 로직 구현
│   └── TcpServer.c        # 서버 로직 구현
└── examples/              # (실행 가능한 메인 예제)
    ├── main_server.c      # 서버 구동 메인
    └── main_client.c      # 클라이언트 구동 메인

```

### 3. 빌드 방식 (CMake & GCC)

네, 모든 파일 작성이 끝나면 마지막 단계에서 아래 두 가지 방식을 모두 제공하겠습니다.

1. **CMake:** `CMakeLists.txt`를 통해 `cmake .. && make`로 빌드하는 법.
2. **GCC:** 터미널에서 `gcc src/*.c examples/main_server.c -o server ...` 처럼 직접 타이핑하는 명령어.

### 4. 진행 방식 확인 (File by File)

네, **파일 단위로 코드를 작성하고 컨펌받는 방식**으로 진행하겠습니다.

### 5. 스타일 가이드 적용

함수 및 제어문의 시작 중괄호 `{`를 **개행(New Line)**하여 작성하겠습니다. (Allman Style)
==========================================================================================================================================================================================================
